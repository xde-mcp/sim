---
title: スタート
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Image } from '@/components/ui/image'

スタートブロックは、Simで構築されたワークフローのデフォルトトリガーです。構造化された入力を収集し、エディターテスト、APIデプロイメント、チャット体験のためにグラフの残りの部分に分岐します。

<div className="flex justify-center">
  <Image
    src="/static/start.png"
    alt="入力フォーマットフィールドを持つスタートブロック"
    width={360}
    height={380}
    className="my-6"
  />
</div>

<Callout type="info">
スタートブロックは、ワークフローを作成するときに開始スロットに配置されます。エディター実行、APIへのデプロイリクエスト、チャットセッションに同じエントリーポイントを提供したい場合は、そのままにしておきます。イベント駆動の実行のみが必要な場合は、WebhookまたはScheduleトリガーと交換してください。
</Callout>

## スタートによって公開されるフィールド

スタートブロックは、実行環境に応じて異なるデータを出力します：

- **入力フォーマットフィールド** — 追加した各フィールドは <code>&lt;start.fieldName&gt;</code> として利用可能になります。例えば、`customerId` フィールドは、下流のブロックとテンプレートで <code>&lt;start.customerId&gt;</code> として表示されます。
- **チャット専用フィールド** — ワークフローがチャットサイドパネルまたはデプロイされたチャット体験から実行される場合、Simは <code>&lt;start.input&gt;</code>（最新のユーザーメッセージ）、<code>&lt;start.conversationId&gt;</code>（アクティブなセッションID）、および <code>&lt;start.files&gt;</code>（チャットの添付ファイル）も提供します。

入力フォーマットフィールドは、後で参照する予定の名前に限定してください—これらの値は、エディター、API、およびチャット実行間で共有される唯一の構造化フィールドです。

## 入力フォーマットの設定

入力フォーマットのサブブロックを使用して、実行モード全体に適用されるスキーマを定義します：

1. 収集したい各値のフィールドを追加します。
2. タイプを選択します（`string`、`number`、`boolean`、`object`、`array`、または `files`）。ファイルフィールドは、チャットとAPIの呼び出し元からのアップロードを受け付けます。
3. 手動実行モーダルにテストデータを自動的に入力させたい場合は、デフォルト値を提供します。これらのデフォルト値はデプロイされた実行では無視されます。
4. フィールドを並べ替えて、エディターフォームでの表示方法を制御します。

接続するブロックに応じて、<code>&lt;start.customerId&gt;</code>のような式を使用して、下流の構造化された値を参照できます。

## エントリーポイントごとの動作

<Tabs items={['エディタ実行', 'APIにデプロイ', 'チャットにデプロイ']}>
  <Tab>
    <div className="space-y-3">
      <p>
        エディタで<strong>実行</strong>をクリックすると、スタートブロックは入力フォーマットをフォームとしてレンダリングします。デフォルト値により、データを再入力せずに簡単に再テストできます。フォームを送信するとワークフローが即座にトリガーされ、値は<code>&lt;start.fieldName&gt;</code>（例えば<code>&lt;start.sampleField&gt;</code>）で利用可能になります。
      </p>
      <p>
        フォーム内のファイルフィールドは対応する<code>&lt;start.fieldName&gt;</code>に直接アップロードされます。これらの値を使用して、下流のツールやストレージステップにデータを供給します。
      </p>
    </div>
  </Tab>
  <Tab>
    <div className="space-y-3">
      <p>
        APIにデプロイすると、入力フォーマットはクライアント向けのJSON契約に変換されます。各フィールドはリクエストボディの一部となり、Simは取り込み時にプリミティブ型を強制変換します。ファイルフィールドはアップロードされたファイルを参照するオブジェクトを想定しています。ワークフローを呼び出す前に、実行ファイルアップロードエンドポイントを使用してください。
      </p>
      <p>
        API呼び出し元は追加のオプションプロパティを含めることができます。これらは<code>&lt;start.fieldName&gt;</code>出力内に保持されるため、すぐに再デプロイせずに実験できます。
      </p>
    </div>
  </Tab>
  <Tab>
    <div className="space-y-3">
      <p>
        チャットデプロイメントでは、スタートブロックはアクティブな会話にバインドされます。最新のメッセージは<code>&lt;start.input&gt;</code>に入力され、セッション識別子は<code>&lt;start.conversationId&gt;</code>で利用可能になり、ユーザーの添付ファイルは<code>&lt;start.files&gt;</code>に表示されます。また、<code>&lt;start.fieldName&gt;</code>としてスコープされた入力フォーマットフィールドも同様です。
      </p>
      <p>
        追加の構造化されたコンテキスト（例えば埋め込みから）でチャットを起動すると、それは対応する<code>&lt;start.fieldName&gt;</code>出力にマージされ、下流のブロックがAPIや手動実行と一貫性を保ちます。
      </p>
    </div>
  </Tab>
</Tabs>

## 下流でのStart（開始）データの参照

- <code>&lt;start.fieldName&gt;</code>を構造化されたペイロードを期待するエージェント、ツール、または関数に直接接続します。
- プロンプトフィールドで<code>&lt;start.sampleField&gt;</code>や<code>&lt;start.files[0].url&gt;</code>（チャットのみ）などのテンプレート構文を使用します。
- 出力のグループ化、会話履歴の更新、またはチャットAPIへのコールバックが必要な場合は、<code>&lt;start.conversationId&gt;</code>を手元に置いておきます。

## ベストプラクティス

- APIとチャットの両方の呼び出し元をサポートしたい場合は、Startブロックを単一のエントリーポイントとして扱います。
- 下流のノードで生のJSONを解析するよりも、名前付き入力フォーマットフィールドを優先します。型の強制変換は自動的に行われます。
- ワークフローが成功するために特定のフィールドが必要な場合は、Startの直後に検証またはルーティングを追加します。

- <code>&lt;start.fieldName&gt;</code>を構造化されたペイロードを期待するエージェント、ツール、または関数に直接接続します。
- プロンプトフィールドで<code>&lt;start.sampleField&gt;</code>や<code>&lt;start.files[0].url&gt;</code>（チャットのみ）などのテンプレート構文を使用します。
- 出力のグループ化、会話履歴の更新、またはチャットAPIへのコールバックが必要な場合は、<code>&lt;start.conversationId&gt;</code>を手元に置いておきます。

## ベストプラクティス

- APIとチャットの両方の呼び出し元をサポートしたい場合は、スタートブロックを単一のエントリーポイントとして扱います。
- 下流のノードで生のJSONを解析するよりも、名前付き入力フォーマットフィールドを優先します。型の強制変換は自動的に行われます。
- ワークフローの成功に特定のフィールドが必要な場合は、スタートの直後に検証またはルーティングを追加します。